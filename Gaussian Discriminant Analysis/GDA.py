# -*- coding: utf-8 -*-
"""ML Exercise 3 Kavish and the Flow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WJtYqrxa_8Mjrl2D_dpeMVNJLooyL9aE

## **Gaussian Discriminant Analysis - ML Exercise 3 - Kavish and Florian**
"""

import numpy as np
import matplotlib.pyplot as plt
from PIL import Image, ImageFilter
import imageio

!git clone https://github.com/KavishBhatia/MachineLearning.git

"""Compute the feature probability distributions for the positive(p) and negative(n) group.
Features:
    1. Mean of all (R)GB values
    2. Mean of all R(G)B values
    3. Mean of all RG(B) values
    4. Lowest(darkest) cumulative RBG value of 2x2 Filter
    5. Mean of all RGB (all 3) values
    
Plot distributions for p and n and check if they are differentiable.

Sum up relative probability for an image to be in p or n according to all feature probabilities.

Get paths of all the negative and positive images
"""

category = ["positives", "negatives"]
ml = "MachineLearning/"

def getPositiveImages():
  image_path = []
  for i in range(1,31):
    if i < 10:
      img_name = "/p0" + str(i)
    else:
      img_name = "/p" +str(i)    
    path = ml + category[0] + img_name + ".png"
    image_path.append(path)
  return image_path  

def getNegativeImages():
  image_path = []
  for i in range(1,31):
    if i < 10:
      img_name = "/n0" + str(i)
    else:
      img_name = "/n" +str(i)    
    path = ml + category[1] + img_name + ".png"
    image_path.append(path)
  return image_path

"""Getting all positive and negative images"""

picturePathListPositive = getPositiveImages()
  picturePathListNegative = getNegativeImages()

"""function to get pixels of an image"""

def getPixelValues(imagepath):
  im = imageio.imread(imagepath)
  return im

"""function to compute Means for a single color in the image and for all the pixel values"""

def computeMeanForAllColours(imagepath):
  pixValues = getPixelValues(imagepath)
  meanPixValues = np.mean(pixValues)
  return meanPixValues

def computeMeanSingleColour(colour, imagepath):
  pixValues = getPixelValues(imagepath)
  meanPixValues = np.mean(pixValues[:,:,colour])
  return meanPixValues

red = 0
green = 1
blue = 2
m = 60 # total number of pos and neg images
n = 5 #no of features

"""function to calculate mean of the image after converting to edges"""

def calcMeanEdges(imagepath):
    image = Image.open(imagepath)
    return np.mean(image.filter(ImageFilter.FIND_EDGES))

"""function to plot histograms for all the features"""

def meanAllValues():
  
  listOfPosMeans = []
  listOfNegMeans = []
  listOfPosRedMeans = [] # pos red means
  listOfPosGreenMeans = [] # pos green means
  listOfPosBlueMeans = [] # pos blue means
  listOfNegRedMeans = [] # neg red means
  listOfNegGreenMeans = [] # neg green means
  listOfNegBlueMeans = [] # neg blue means
  listOfPosFilterMeans = [] # Filter means
  listOfNegFilterMeans = [] # Filter means
  
  NegEdges = []
  PosEdges = []
    
  for i in picturePathListPositive:
    listOfPosMeans.append(computeMeanForAllColours(i))
    listOfPosRedMeans.append(computeMeanSingleColour(red,i))
    listOfPosGreenMeans.append(computeMeanSingleColour(green,i))
    listOfPosBlueMeans.append(computeMeanSingleColour(blue,i))
    listOfPosFilterMeans.append(filterMaxMean(i))
    
    PosEdges.append(calcMeanEdges(i))
   
  for i in picturePathListNegative:
    listOfNegMeans.append(computeMeanForAllColours(i))
    listOfNegRedMeans.append(computeMeanSingleColour(red,i))
    listOfNegGreenMeans.append(computeMeanSingleColour(green,i))
    listOfNegBlueMeans.append(computeMeanSingleColour(blue,i))
    listOfNegFilterMeans.append(filterMaxMean(i))
    
    NegEdges.append(calcMeanEdges(i))
    
  bins = np.linspace(15, 60, 10)
  plt.hist(PosEdges, bins, alpha=0.5, label='positive edges')
  plt.hist(NegEdges, bins, alpha=0.5, label='negative edges')
  plt.legend()
  plt.show()
  
  

  bins = np.linspace(100, 200, 25)
  plt.hist(listOfPosMeans, bins, alpha=0.5, label='positive mean all colours')
  plt.hist(listOfNegMeans, bins, alpha=0.5, label='negative mean all colours')
  plt.legend()
  plt.show()

  bins = np.linspace(100, 200, 25)
  plt.hist(listOfPosRedMeans, bins, alpha=0.5, label='positive red mean')
  plt.hist(listOfNegRedMeans, bins, alpha=0.5, label='negative red mean')
  plt.legend()
  plt.show()
    
  bins = np.linspace(100, 200, 25)
  plt.hist(listOfPosGreenMeans, bins, alpha=0.5, label='positive green mean')
  plt.hist(listOfNegGreenMeans, bins, alpha=0.5, label='negative green mean')
  plt.legend()
  plt.show()

  bins = np.linspace(100, 200, 25)
  plt.hist(listOfPosBlueMeans, bins, alpha=0.5, label='positive blue mean')
  plt.hist(listOfNegBlueMeans, bins, alpha=0.5, label='negative blue mean')
  plt.legend()
  plt.show()
  
  bins = np.linspace(100, 200, 25)
  plt.hist(listOfPosFilterMeans, bins, alpha=0.5, label='positive filter')
  plt.hist(listOfNegFilterMeans, bins, alpha=0.5, label='negative filter')
  plt.legend()
  plt.show()

"""function to get the Maximum or the darkest spot in the image from a 2x2 filter"""

def filterMaxMean(image):
  img = Image.open(image)
  members = [(0,0)] * 4
  filteredMeanMax = 255
  for i in range(1,23):
    for j in range(1,23):
        members[0] = img.getpixel((i-1,j-1))
        members[1] = img.getpixel((i-1,j))
        members[2] = img.getpixel((i-1,j+1))
        members[3] = img.getpixel((i,j-1))
        tempFilteredMeanMax = np.mean(members)
        if tempFilteredMeanMax < filteredMeanMax:
          filteredMeanMax = tempFilteredMeanMax
  return (filteredMeanMax - 255)*(-1)

meanAllValues()

"""function to get all features for a single image

All Features except for mean green pixel values seem to allow for decent destinction between the classes. G
"""

def getFeaturesOneImage(imagepath):
    X = []
    X.append(filterMaxMean(imagepath))
    X.append(computeMeanForAllColours(imagepath))
    X.append(computeMeanSingleColour(red, imagepath))
    X.append(computeMeanSingleColour(blue, imagepath))
    X.append(calcMeanEdges(imagepath))
    X = np.asarray(X).reshape(1,n)
    return X

"""function to calculate mu0, mu1 and sigma"""

def computeParameters():
    flag = 0
    meanMaxPos = []
    meanMaxNeg = []
    meanAllColorNeg = []
    meanAllColorPos = []
    meanRedNeg = []
    meanRedPos = []
    meanBlueNeg = []
    meanBluePos = []
    
    meanEdgeNeg = []
    meanEdgePos = []
    
    mu0 = []
    mu1 = []
    sig = []
    
    for i in range(60):
        if i >= 30:
            flag = 1
        if flag == 0:
            meanMaxNeg.append(filterMaxMean(picturePathListNegative[i]))
            meanAllColorNeg.append(computeMeanForAllColours(picturePathListNegative[i]))
            meanRedNeg.append(computeMeanSingleColour(red, picturePathListNegative[i]))
            meanBlueNeg.append(computeMeanSingleColour(blue, picturePathListNegative[i]))
    
            meanEdgeNeg.append(calcMeanEdges(picturePathListNegative[i]))
        elif flag == 1:
            i = i - 30
            meanMaxPos.append(filterMaxMean(picturePathListPositive[i]))
            meanAllColorPos.append(computeMeanForAllColours(picturePathListPositive[i]))
            meanRedPos.append(computeMeanSingleColour(red, picturePathListPositive[i]))
            meanBluePos.append(computeMeanSingleColour(blue, picturePathListPositive[i]))
            meanEdgePos.append(calcMeanEdges(picturePathListPositive[i]))
    
    mu0.append(np.mean(meanMaxNeg))
    mu0.append(np.mean(meanAllColorNeg))
    mu0.append(np.mean(meanRedNeg))
    mu0.append(np.mean(meanBlueNeg))
    mu0.append(np.mean(meanEdgeNeg))
    
    mu1.append(np.mean(meanMaxPos))
    mu1.append(np.mean(meanAllColorPos))
    mu1.append(np.mean(meanRedPos))
    mu1.append(np.mean(meanBluePos))
    mu1.append(np.mean(meanEdgePos))
    
    mu0 = np.asarray(mu0).reshape(1,n)
    mu1 = np.asarray(mu1).reshape(1,n)
    
    SIG = np.zeros((n,n)) #dimensions
    for i in picturePathListNegative:
        X = getFeaturesOneImage(i)
        X = np.asarray(X).reshape(1,n)
        sub = np.subtract(X,mu0)
        SIG += np.dot(sub.T,sub)
    
    for i in picturePathListPositive:
        X = getFeaturesOneImage(i)
        X = np.asarray(X).reshape(1,n)
        sub = np.subtract(X,mu1)
        SIG += np.dot(sub.T,sub)
    
    #print(SIG*(1/m))
    return mu0,mu1,SIG*(1/m)

"""function to apply GDA on the images"""

def gda():
  negVecMean, posVecMean, determinant = computeParameters()
  print(negVecMean, posVecMean)

  phi=0.5
  dimensions = n #number of features
  
  picturePathList = []
  picturePathList = picturePathListNegative + picturePathListPositive
  
  classifiedList = []
   
  denominator = (2 * np.pi)**(dimensions/2) * np.sqrt(np.linalg.det(determinant))
  
  for i in picturePathList:
    vecImg = []
    vecImg = getFeaturesOneImage(i)
    vector = vecImg - negVecMean
    
    probClass0 = np.exp(-0.5 * (vecImg - negVecMean) @ (np.linalg.inv(determinant) @ (vecImg - negVecMean).T)) / denominator
    probClass1 = np.exp(-0.5 * (vecImg - posVecMean) @ (np.linalg.inv(determinant) @ (vecImg - posVecMean).T)) / denominator
    
    if probClass0 > probClass1:
      classifiedList.append('0')
    else:
      classifiedList.append('1')
  
  
  return classifiedList

classifierList = gda()
classifierList

